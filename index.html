<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="welcome to i2Life&apos;s page">
<meta property="og:type" content="website">
<meta property="og:title" content="i2Life">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="i2Life">
<meta property="og:description" content="welcome to i2Life&apos;s page">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="i2Life">
<meta name="twitter:description" content="welcome to i2Life&apos;s page">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>i2Life</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">i2Life</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">welcom to i2Life's page</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的多线程-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的多线程-二/" itemprop="url">说说java中的多线程(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T16:47:49+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>在前面提到过，多线程会有线程安全的问题，如果多个线程同时去访问共享资源（并发访问），可能导致程序运行错误。</p>
<p>如何解决由于并发访问而导致的线程安全问题呢？</p>
<p>一般都是采用线程同步互斥访问的方法来处理，”序列化访问临界资源”，即在同一时间，只允许一个线程访问临界资源。</p>
<p>java中通常有两种方法来实现线程同步：synchronized机制和同步阻塞队列。</p>
<h3 id="synchronized机制"><a href="#synchronized机制" class="headerlink" title="synchronized机制"></a>synchronized机制</h3><p>有一个互斥锁的概念，对临界资源加上互斥锁后，线程只有获得了该临界资源的互斥锁才能访问该资源。</p>
<p>在java中每一个对象都有一个内部的互斥锁，如果一个方法用synchronized关键字声明，则对象的锁会保护整个方法，那么如果需要调用该方法，必须获得内部的锁对象。</p>
<p>内部对象锁只有一个相关条件（相关条件：就是线程获得锁对象之后，可能有一些条件判断才能继续执行，而这些条件又必须其他的线程执行才能满足，这个时候就需要对当前对象进行释放锁）。</p>
<p>看一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" print num "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义线程类</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      PrintNum.printNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数中起两个线程，并start</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread threadOne = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        threadOne.start();</span><br><span class="line"></span><br><span class="line">        Thread threadTwo = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">        threadTwo.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span> print num <span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>线程0和线程1交叉打印数字。</p>
<p>现在将printNum方法声明为synchronized：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" print num "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> print num <span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">1</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> print num <span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">3</span></span><br><span class="line">Thread-<span class="number">1</span> print num <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>使用了synchronized关键字，线程进行了同步处理，线程0运行完了，释放内部锁之后，线程1才能执行。</p>
<p><strong>关于synchronized关键字的几点说明：</strong></p>
<blockquote>
<p>1) 当一个线程正在访问对象的synchronized方法，其他线程不能再访问该对象的其他synchronized方法，因为一个对象只有一个互斥锁；<br>2) 当一个线程正在访问对象的synchronized方法，其他线程可以访问该对象的非synchronized方法；<br>3) 访问同一个类的不同对象实例的synchronized方法，不存在线程安全问题。</p>
</blockquote>
<h3 id="同步阻塞机制（也称为synchronized代码块）"><a href="#同步阻塞机制（也称为synchronized代码块）" class="headerlink" title="同步阻塞机制（也称为synchronized代码块）"></a>同步阻塞机制（也称为synchronized代码块）</h3><p>java中还有另外一种获取锁的方式：synchronized代码块。</p>
<p>有的时候把一整个方法声明为synchronized并不一定合适，比如该方法中只有一部分代码需要同步互斥访问，这个时候可以使用synchronized代码块，只对需要同步的那部分代码进行同步。</p>
<p>举例子，上面的代码可以将printNum方法声明synchronized代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintNum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" print num "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明一点，这里定义的是static方法，并没有定义PrintNum对象，所以不光对象实例有锁，类也有锁。</p>
<p><strong>Tips:</strong></p>
<blockquote>
<ol>
<li>如果一个线程执行对象的非static synchronized方法，另一个线程执行该类的static synchronized方法，不存在互斥问题，因为访问static synchronized方法占用的是类锁，访问非static synchronized方法占用的是对象锁，所以不存在资源互斥的问题；</li>
<li>对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</li>
</ol>
</blockquote>
<h3 id="volatile域"><a href="#volatile域" class="headerlink" title="volatile域"></a>volatile域</h3><p>volatile也是java提供的一种轻量级的同步机制。</p>
<p>有的时候，仅仅为了读写一两个实例域就使用同步锁，开销会比较大，那么就可以考虑使用volatile域。</p>
<p>volatile为实例域的同步访问提供了一种免锁机制，如果声明一个域为volatile，那么编译期虚拟机就知道该域是被另一个线程并发更新的。</p>
<p><strong>并发编程中的三个概念：</strong></p>
<blockquote>
<ol>
<li>原子性：一个操作要么全部执行并且执行的过程中不允许中断，要么不执行；</li>
<li>可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程也能立即看到修改的值；</li>
<li>有序性：是指程序执行的顺序按照代码的先后顺序执行。<br>volatile可以保证共享变量的可见性和有序性，不能保证共享变量的原子性。</li>
</ol>
</blockquote>
<p>被volatile修饰的变量，会强制将修改的值立即写入主存，这样其他线程就可以知道该变量的值得到了修改，从而保证了可见性；被volatile修饰的变量，禁止指令重排，保证了有序性。</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>队列分为非阻塞队列和阻塞队列。非阻塞队列的一个问题是，不会对当前线程产生阻塞，那么在面对类似消费者-生产者模型时，就必须额外的实现同步机制来保证线程安全。</p>
<p>阻塞队列，可以对当前线程产生阻塞，如果一个线程从空的阻塞队列中读取元素，或者往一个满的阻塞队列中放入元素，线程都会被阻塞，直到阻塞队列满足当前的操作，被阻塞的队列会自动被唤醒。</p>
<h4 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h4><p><strong>LinkedBlockingQueue</strong>:基于链表实现的阻塞队列，如果没有指定队列容量大小，默认大小为Integer.MAX_VALUE;<br><strong>ArrayBlockingQueue</strong>:基于数组实现的阻塞队列，在构造该队列对象时，必须指定容量，并且有一个可选的参数来指定时候需要公平性，如果设置了公平参数，那么等待了最长时间的线程会得到处理，一般，公平性会牺牲性能，所以默认是非公平的。<br><strong>PriorityBlockingQueue</strong>:上面两种队列都是先进先出的队列，PriorityBlockingQueue是带优先级的队列，元素按照优先级顺序从队列移出。且该队列是无界阻塞队列，容量没有上限，上面两种队列都是有界队列。<br><strong>DelayQueue</strong>:基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当指定的时间到了，才能够从队列中获取到该元素，DelayQueue也是无界队列。</p>
<h4 id="非阻塞队列和阻塞队列的方法"><a href="#非阻塞队列和阻塞队列的方法" class="headerlink" title="非阻塞队列和阻塞队列的方法"></a>非阻塞队列和阻塞队列的方法</h4><p><strong>1. 非阻塞队列的几个主要方法：</strong><br>add(E e)：将元素e插入到队列尾部，如果插入成功，返回true，如果插入失败（如队列满），则抛出异常；<br>remove():移除队列首元素，若移除成功，则返回true，否则抛异常；<br>offer(E e)：将元素e插入到队列尾部，插入成功，返回true，否则返回false；<br>poll():移除并获取队列首元素，获取成功返回队首元素，失败返回null；<br>peek():获取队列首元素，若成功，则返回队首元素，失败返回null。</p>
<p>对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法，因为这样可以通过返回值判断操作成功与否。注意非阻塞队列中的方法都没有进行同步处理。</p>
<p><strong>2. 阻塞队列的几个主要方法：</strong><br>阻塞队列包括非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在，但是要注意这5个方法在阻塞队列中都进行了同步处理，除此之外，阻塞队列提供了另外4个非常有用的方法：</p>
<p>put(E e)：向队尾存入元素，如果队列满，则等待；<br>take()：从队首取元素，如果队列空，则等待；<br>offer(E e, long timeout, TimeUnit unit)：向队尾存入元素，如果队列满，等待一定时间，到达等到时间上限，如果还没有插入成功，则返回false，否则返回true；<br>poll(long timeout, TimeUnit unit)：从队首取元素，如果空，则等待一定时间，如果还是没有取到，则返回null，否则返回取到的元素。</p>
<h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><p>上面讨论的阻塞队列就是线程安全的集合，java.util.concurrent还提供了一些其他的线程安全的集合：<br>线程安全的map：<br>ConcurrentHashMap:构造一个可以被多线程访问的hashmap<br>ConcurrentSkipListMap:构造一个可以被多线程安全访问的有序map</p>
<p>线程安全的set：<br>ConcurrentSkipListSet:构造一个可以被多线程安全访问的有序集</p>
<p>线程安全的queuue：<br>ConcurrentLinkedQueue:构造一个可以被多个线程安全访问的无边界的非阻塞队列</p>
<h3 id="同步包装器"><a href="#同步包装器" class="headerlink" title="同步包装器"></a>同步包装器</h3><p>Vector和Hashtable提供了线程安全的动态数组和散列表的实现，ArrayList和HaspMap不是线程安全的，但是可以通过同步包装器变成线程安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; synchArrayList = Collections.synchronizedList(<span class="keyword">new</span> ArrayList &lt;&gt;());</span><br><span class="line">Map&lt;K,V&gt; synchHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap &lt;&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的多线程-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的多线程-一/" itemprop="url">说说java中的多线程(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T16:40:15+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程的基本概念"><a href="#多线程的基本概念" class="headerlink" title="多线程的基本概念"></a>多线程的基本概念</h2><p>今天周末，难得清闲，靠着窗户，打开电脑，一边看文档，一边听音乐，还可以开个迅雷下个小电影，惬意！</p>
<p>电脑之所以能同时做这么多事，其实是多进程的功劳，adobe进程负责打开pdf文档，网易云音乐进程负责播放音乐，迅雷进程负责下载电影，各个进程互不干扰。</p>
<p>有个算法好像要参考另外一篇文档，于是我们打开另外一个pdf，这个时候我们并不需要关掉原来的pdf，这是因为每个进程又引入了多线程技术。</p>
<p>当然你可能会问，新打开一个pdf为什么不是重新起了一个adobe进程呢，这个好办，打开计算机的任务管理器看一下当前系统的进程，你会发现只有一个adobeReader进程。</p>
<p>再举个例子，你想下载一个文件，那么在迅雷再创建一个下载任务就可以，一个迅雷进程执行了多个下载任务，这也是多线程。</p>
<p><strong>进程</strong>：进程是操作系统进行资源分配的基本单位，每个进程拥有独立的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰，进程让操作系统的并发成为可能。</p>
<p><strong>线程</strong>：线程是操作系统进行调度的基本单位，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和空间地址的，线程让进程的并发成为可能。</p>
<p>由于线程共享进程的资源和内存空间，那么多个线程如果同时访问某个共享资源怎么办呢，所以引发了进程间的同步问题，这也是多线程编程的难点。然而，也正因为线程是资源共享的，所以线程间通信更容易、线程切换更高效，线程也就比进程更加轻量化。</p>
<h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><p>在java中创建线程有两种方法：</p>
<blockquote>
<p>1)继承Thread类；<br>2)实现Runnable接口。</p>
</blockquote>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><blockquote>
<ol>
<li>创建一个类继承Thread;</li>
<li>重新run方法；</li>
<li>创建一个该类对象；</li>
<li>类对象.start()启动线程。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadOne</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"create thread method one."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CreateThreadOne threadOne = <span class="keyword">new</span> CreateThreadOne();</span><br><span class="line">        threadOne.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><blockquote>
<ol>
<li>创建一个类实现Runnable接口；</li>
<li>实现run函数；</li>
<li>创建该类对象；</li>
<li>通过该类对象创建一个线程对象；</li>
<li>线程对象.start()启动线程。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTwo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"create thread method two."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CreateThreadTwo threadTwo = <span class="keyword">new</span> CreateThreadTwo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(threadTwo);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>从new一个线程到线程的生命周期结束，会经历多个状态，一般线程主要包括以下几个状态：</p>
<blockquote>
<ol>
<li>New(新生)</li>
<li>Runnable(就绪)</li>
<li>Running(运行)</li>
<li>Block(阻塞)</li>
<li>Time waiting(计时等待)</li>
<li>Waiting(等待)</li>
<li>Dead(消亡)</li>
</ol>
</blockquote>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>线程属性一般包括线程的优先级、线程是否为守护线程、线程组以及处理未捕获异常的处理器。</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>线程调度器根据线程优先级调度线程，默认情况下，一个线程继承它的父线程的优先级，可以通过setPriority()设置线程的优先级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(<span class="number">3</span>);<span class="comment">//设置线程优先级</span></span><br><span class="line">thread.MIN_PRIORITY;<span class="comment">//线程最小优先级，１</span></span><br><span class="line">thread.MAX_PRIORITY;<span class="comment">//线程最大优先级，１０</span></span><br><span class="line">thread.NORM_PRIORITY;<span class="comment">//线程的默认优先级，５</span></span><br><span class="line">thread.yield();<span class="comment">//线程让步，让CPU处理其他线程</span></span><br></pre></td></tr></table></figure>

<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程和用户线程的区别：<br>守护线程依赖于创建它的线程，而用户线程则不依赖。<br>举个例子，如果在main线程中创建了一个守护线程，那么当main方法运行完毕之后，守护线程也会随着消亡，而用户线程则不会，用户线程会一直运行直到运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>);<span class="comment">//将线程设置为守护线程，该方法必须在线程启动前调用</span></span><br><span class="line">isDaemon();<span class="comment">//判断线程是否为守护线程</span></span><br></pre></td></tr></table></figure>

<h3 id="未捕获异常处理器"><a href="#未捕获异常处理器" class="headerlink" title="未捕获异常处理器"></a>未捕获异常处理器</h3><p>线程的run方法不能抛出任何已检查异常，但是遇到未检查异常，线程会终止。<br>JVM提供了线程的未捕获异常处理机制，通过未捕获异常处理器进行处理。</p>
<h3 id="设置未捕获异常处理器"><a href="#设置未捕获异常处理器" class="headerlink" title="设置未捕获异常处理器"></a>设置未捕获异常处理器</h3><p>通过Thread的setUncaughtExceptinHandler方法设置线程的未捕获异常处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUncaughtExceptionHandler</span><span class="params">(UncaughtExcpetionHandler eh)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该处理器必须属于一个实现Thread.UncaughtExceptionhandler接口的类，该接口只有一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如下代码，给线程设置了一个未捕获异常处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThreadTwo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] num =</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExcepitonHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"catch a uncaughtException."</span>);</span><br><span class="line">        System.out.println(e.fillInStackTrace());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CreateThreadTwo threadTwo = <span class="keyword">new</span> CreateThreadTwo();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(threadTwo);</span><br><span class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExcepitonHandler());</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">catch</span> a uncaughtException.</span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>捕获了一个未处理异常：java.lang.ArrayIndexOutOfBoundsException: 3</p>
<p>除了上述方法，也可以setDefaultUncaughtExceptionhandler为所有线程安装一个默认的处理器。</p>
<h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>看一下Thread类的getUncaughtExeptionHandler方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UncaughtExceptionHandler <span class="title">getUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uncaughtExceptionHandler != <span class="keyword">null</span> ?</span><br><span class="line">            uncaughtExceptionHandler : group;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果没有给线程设置未捕获异常处理器，则使用线程所在的线程组对象来处理未捕获异常。</p>
<p>看ThreadGroup的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">                System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                                 + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadGroup实现了UncaughtExceptionHandler接口，所以可以用来处理未捕获异常。</p>
<p>uncaughtException的处理逻辑如下：</p>
<blockquote>
<ol>
<li>如果该线程有父线程组，则调用父线程组的uncaughtException方法；</li>
<li>否则，如果返回的默认处理器不为空，则调用默认处理器的uncaughtException方法；</li>
<li>否则，如果Throwalbe e是ThreadDeath的实例，do nothing;</li>
<li>否则打印线程的名称以及栈跟踪。</li>
</ol>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的集合框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的集合框架/" itemprop="url">说说java中的集合框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T12:39:41+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>选择合适的数据结构是优雅的解决问题的关键之一。</p>
<p>java提供了一组集合框架帮助我们实现常用的数据结构，今天就对java中的集合进行一个总结。</p>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>java集合类库构成了集合类的框架。java集合框架将接口与实现分离，接口定义集合的基本方法，在实现类里对这些方法进行实现。为了减少实现类要实现接口的所有方法带来的繁琐，java集合框架还定义了一些抽象类，实现类也可以直接继承抽象类，这样实现类可以只实现想实现的方法。</p>
<p>java集合包含两个基本的接口:Collection和Map。Collection又分为三个子类：List、Set、Queue。常用的集合实现类有：ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap以及LinkedHashMap等。</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection接口是单元素集合的父接口，定义了很多方法：</p>
<p>对于这些方法的详细说明可以参照API文档，下面对Collection接口的三个子接口:List、Set、Queue进行介绍。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List接口是Collection的子接口，List接口可以用来定义一个有序的、元素可重复的集合。</p>
<p>List集合中每个元素都有对应的索引，可以通过索引来访问指定位置的集合元素，List集合默认按照元素的添加顺序设置元素的索引，比如第一个添加的元素索引为0……</p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList和Vector类都是基于数组实现的List集合，所以ArrayList和Vector类封装了一个动态的、允许再分配的Object[]数组。ArrayList或Vector对象使用initalCapacity参数来设置该数组的长度，当向ArrayList或Vector中添加元素超过了该数组的长度时，他们的initalCapacity会自动增加。</p>
<p><strong>遍历ArrayList的方法一：</strong><br>迭代器遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"a"</span>);</span><br><span class="line">        names.add(<span class="string">"b"</span>);</span><br><span class="line">        Iterator iter = names.iterator();</span><br><span class="line">        <span class="keyword">while</span> ((iter).hasNext()) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历ArrayList的方法二：</strong><br>索引遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"a"</span>);</span><br><span class="line">        names.add(<span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">            System.out.println(names.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历ArrayList的方法三：</strong><br>foreach循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String name:names)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过索引遍历ArrayList的效率最高，迭代器访问效率最低。</p>
<p><strong>ArrayList和Vector的区别：</strong></p>
<blockquote>
<ol>
<li>ArrayList是线程不安全的，Vector是线程安全的；</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>Vector的性能比ArrayList差。</li>
</ol>
</blockquote>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList是基于链表实现的List集合，插入和删除元素的效率较高。所以需要经常在集合中间插入或删除元素，可以考虑选用LinkedList集合。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set接口也是扩展自Collection接口，与List不同，Set不允许重复的元素，Set接口有3个具体的实现类：HashSet、LinkedHashSet、TreeSet。</p>
<h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>HashSet使用Hash算法来存储集合中的元素，具有很好的存取和查找性能。<br><strong>HashSet的特点：</strong></p>
<blockquote>
<ol>
<li>不能保证元素的顺序；</li>
<li>HashSet不是同步的，如果多个线程同时访问一个HashSet，则必须通过同步机制来保证线程安全；</li>
<li>集合元素值可以是null。</li>
</ol>
</blockquote>
<h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>LinkedHashSet是用一个链表实现来对HashSet进行扩展，它支持对规则集内的元素排序，使得元素是以插入的顺序来保存的。</p>
<p>当遍历LinkedHashSet时，将会按照元素的添加顺序来访问集合中的元素，由于要维护元素的插入顺序，所以性能略低于HashSet，但在迭代访问Set里的全部元素时，有很好的性能。</p>
<h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>TreeSet是一个有序的Set，可以确保集合元素处于排序状态，不是插入顺序。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue是一种先进先出的数据结构，Queue接口也是扩展自Collection接口。</p>
<p>因为LinkedList类实现了Deque接口，所以我们通常可以使用LinkedList来创建一个队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">"a"</span>);</span><br><span class="line">        queue.offer(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>Map是用来存储键值对的容器类，在Map中键可以是任意类型的对象，但不能有重复的键，每个Key都对应一个value。</p>
<p>Map接口有3个具体的实现类：HashMap、LinkedHashMap、TreeMap。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>看一下HashMap的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line">HashMap()</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定容量大小的构造函数</span></span><br><span class="line">HashMap(<span class="keyword">int</span> capacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定容量大小和加载因子的构造函数</span></span><br><span class="line">HashMap(<span class="keyword">int</span> capacity, <span class="keyword">float</span> loadFactor)</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含子Map的构造函数</span></span><br><span class="line">HashMap(Map&lt;? extends K, ? extends V&gt; map)</span><br></pre></td></tr></table></figure>

<p>从构造函数中，了解到两个重要的元素：容量大小(capacity)和加载因子(loadFactor)。<br>容量是哈希表的容量，初始容量是哈希表在创建时的容量(即DEFAULT_INITIAL_CAPACITY=1&lt;&lt;4)。</p>
<p>加载因子是哈希表在其容量自动增加前可以达到多满的一种尺度。当哈希表中的条目数超过了加载因子与当前容量的乘积时，则要对该哈希表进行resize操作，从而哈希表将具有大约两倍的桶数。</p>
<p>通常，默认加载因子是0.75，这是在时间和空间成本上的一种折中。加载因子过高虽然减少了空间开销，但同时也增加了查询成本，在设置容量时应该考虑到映射中所需要的条目数和加载因子，以便最大限度地减少resize操作次数。</p>
<p><strong>HashMap的遍历方式：</strong></p>
<blockquote>
<ol>
<li>遍历HashMap的键值对；<br>第一步：根据EntrySet()获取HashMap的键值对的Set集合。<br>第二步：通过Iterator迭代器遍历第一步得到的集合。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>遍历HashMap的键<br>第一步：根据KeySet()获取HashMap的“键”的Set集合。<br>第二步：通过Iterator迭代器遍历第一步得到的集合。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>遍历HashMap的值<br>第一步：根据value()获取HashMap的值的集合。<br>第二步：通过Iterator迭代器遍历第一步得到的集合。</li>
</ol>
</blockquote>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>HashSet有一个linkedHashSet子类，HashMap也有一个LinkedHashMap子类；LinkedHashMap使用双向链表来维护Key-value对的次序。</p>
<p>LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能；但是因为它以链表来维护内部顺序，所以在迭代访问Map里的全部元素时有较好的性能，迭代输出LinkedHashMap的元素时，将会按照添加key-value对的顺序输出。</p>
<p>本质上来讲，LinkedHashMap=散列表+循环双向链表。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap是SortedMap接口的实现类，TreeMap是一个有序的key-value集合，它是通过红黑树来实现的，每个key-value对即作为红黑树的一个节点。</p>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><p>上面主要对java集合框架中的一些常用接口和类进行了介绍，包括Collection和Map接口及他们的抽象类和常用的具体实现类。下面介绍一下其他几个特殊的集合类：</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>前面已经提到，java设计者在对之前的容器进行重新设计时保留了一些数据结构，其中就有Vector，用法上Vector与ArrayList基本一致，不同之处在与Vector使用了关键字synchronized将访问和修改向量的方法都变成同步的了，所以Vector是线程安全的。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack，栈类，继承自Vector。</p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>HashTable和前面介绍的HashMap比较类似，它也是一个散列表，存储的内容是键值对映射，不同之处在于，HahsTable继承自Ditionary，HashTable中的函数都是同步的，HashTable也是线程安全的。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>Concurrent，并发，从名字就可以看出ConcurrentHashMap是HashMap的线程安全版，同HashMap相比，ConcurrentHashMap不仅保证了访问的线程安全性，而且在效率上也有较大提高。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList是一个线程安全的List接口的实现，它使用了ReenTrantLock锁来保证在并发情况下提供高性能的读取</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的泛型-三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的泛型-三/" itemprop="url">说说java中的泛型(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T12:32:07+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="泛型中的继承规则"><a href="#泛型中的继承规则" class="headerlink" title="泛型中的继承规则"></a>泛型中的继承规则</h2><p>我们定义这样一个泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>Result&lt;Person&gt;</code>和<code>Result&lt;Student&gt;</code>有什么关系呢，其中<code>Student</code>是<code>Person</code>类的子类。</p>
<p>答案是他们没有关系，<code>Result&lt;Student&gt;</code>并不是<code>Result&lt;Person&gt;</code>的子类，通常无论S和T有什么关系，<code>Result&lt;S&gt;</code>和<code>Result&lt;T&gt;</code>都没有什么关系。</p>
<p>泛型类可以扩展或实现其他泛型类或泛型接口，这跟普通的类和接口没有区别。</p>
<h2 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h2><h3 id="通配符的子类型限定"><a href="#通配符的子类型限定" class="headerlink" title="通配符的子类型限定"></a>通配符的子类型限定</h3><p>通过泛型类型的继承规则，我们知道，<code>Result&lt;Student&gt;</code>和<code>Result&lt;Person&gt;</code>并没有什么关系，换言之他们是不同的类型，下面我们想定义一个printName方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先定义Student类和Person类</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义printName函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person xiaoming = <span class="keyword">new</span> Person(<span class="string">"xiaoming"</span>);</span><br><span class="line"></span><br><span class="line">        Student xiaoqiang = <span class="keyword">new</span> Student(<span class="string">"xiaoqiang"</span>);</span><br><span class="line"></span><br><span class="line">        Result&lt;Person&gt; input1 = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">        input1.setValue(xiaoming);</span><br><span class="line"></span><br><span class="line">        Result&lt;Student&gt; input2 = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">        input2.setValue(xiaoqiang);</span><br><span class="line"></span><br><span class="line">        printName(input1);</span><br><span class="line"></span><br><span class="line">        printName(input2);<span class="comment">//报编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(Result&lt;Person&gt; input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(input.getValue().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现printName(input2);语句报编译错误，如果我们想打印Result<student>类型入参的姓名，得再定义一个printName方法，参数类型为Result<student>。</student></student></p>
<p>这样就显得很冗余，那么可以考虑使用通配符来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(Result&lt;? extends Person&gt; input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   System.out.println(input.getValue().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>? extends Person</code>表示<code>Person</code>的所有子类。</p>
<h3 id="通配符的超类型限定"><a href="#通配符的超类型限定" class="headerlink" title="通配符的超类型限定"></a>通配符的超类型限定</h3><p>通配符除了可以指定子类型限定，还可以指定超类型限定，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? <span class="keyword">super</span> Student</span><br></pre></td></tr></table></figure>

<p>表示Student类的所有超类型。</p>
<h2 id="泛型类型的约束与局限"><a href="#泛型类型的约束与局限" class="headerlink" title="泛型类型的约束与局限"></a>泛型类型的约束与局限</h2><p>最后总结一下泛型的约束与局限性，大多数约束都是由于类型擦除导致的。</p>
<blockquote>
<ol>
<li>不能使用基本类型实例化类型参数。<br>因此没有Result<double>，只有Result<double>，这是因为类型擦除导致的，擦除之后Result类的成员为Object类型，而Object不能存储double这样的基本类型。</double></double></li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>运行时类型查询只适用原始类型。<br>因为虚拟机中的对象总有一个特定的非泛型类型，所以所有的类型查询只产生原始类型。<br>比如if(a instanceof Pair<string>，实际上等价于if(a instanceof Pair<t>。</t></string></li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>不能抛出也不能捕获泛型类异常。<br>事实上，泛型类扩展Throwable都不合法：public class Problem<t> extends Exception{…}不能通过编译。</t></li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>参数化类型的数组不合法<br>Pair<string>[] table = new pair<string>[10]是错误的。</string></string></li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>不能实例化类型变量。<br>不能使用像new T();T.class之类的表达式。</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li>泛型类的静态上下文中类型变量无效</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">getSingleInstance</span><span class="params">()</span><span class="comment">//Error</span></span></span><br><span class="line"><span class="function">    </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的泛型-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的泛型-二/" itemprop="url">说说java中的泛型(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T12:24:01+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类型变量的限定"><a href="#类型变量的限定" class="headerlink" title="类型变量的限定"></a>类型变量的限定</h2><p>上一篇中，我们知道了泛型类、泛型接口、泛型的方法的定义和使用。</p>
<p>现在我们定义一个泛型方法，找到两个数中的最小值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMin</span><span class="params">(T num1, T num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1.compareTo(num2) &lt; <span class="number">0</span> ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接这样定义，编译器会报错,无法解析compareTo方法。</p>
<p>因为num1类型是一个泛型T，编译器不能确定该对象是否实现了compareTo方法，那么怎么来保证T类型的变量一定实现了compareTo方法呢？通过类型限定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">getMin</span><span class="params">(T num1, T num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1.compareTo(num2) &lt; <span class="number">0</span> ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T extends Comparale限定T必须是实现了Comparable接口的类型。</p>
<p>一个类型变量可以有多个限定，基本语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//限定类型用&amp;分隔，类型变量用，分隔</span></span><br><span class="line">&lt;T extends Type1 &amp; Type2, U extends Type3&gt;</span><br></pre></td></tr></table></figure>

<p>由于TypeT可根据java的继承规则，可以是类也可以是接口，所以这里用关键字extends，表示T是Type的字类型。</p>
<p><strong>根据java的继承规则，限定列表中可以有多个接口类型，但是最多只能有一个类，如果一个类作为限定，则类必须是限定列表的第一个。</strong></p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>通过上面的一些例子，我们能看到泛型的用处，但是，泛型特性并不是java一开始就有的特性，而是在java1.5才引入的，那么为了跟引入泛型特性之前的代码保持兼容，就必须的做些事情。</p>
<p>因为java1.5前的代码并没有泛型的概念，所以java泛型只能用于在编译期间的静态类型检查，通过编译生成的代码要进行类型擦除，相当于擦掉泛型的痕迹，这样到了运行期JVM就感知不到泛型的存在了，从而能够跟以前的代码保持兼容。</p>
<p>简单理解就是，为了跟以前的代码保持兼容，java虚拟机没有泛型类型对象，所以无论何时定义一个泛型类型，通过编译器后都要进行类型擦除。</p>
<p><strong>类型擦除的规则：</strong></p>
<blockquote>
<p>擦除类型变量，并替换为限定类型列表里的第一个限定类型，如果没有给出限定类型，则用Object替换。</p>
</blockquote>
<h3 id="example-1-有限定列表的类型擦除"><a href="#example-1-有限定列表的类型擦除" class="headerlink" title="example 1:有限定列表的类型擦除"></a>example 1:有限定列表的类型擦除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">getMin</span><span class="params">(T num1, T num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1.compareTo(num2) &lt; <span class="number">0</span> ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title">getMin</span><span class="params">(Comparable num1, Comparable num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1.compareTo(num2) &lt; <span class="number">0</span> ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="example-2-无限定列表的类型擦除"><a href="#example-2-无限定列表的类型擦除" class="headerlink" title="example 2:无限定列表的类型擦除"></a>example 2:无限定列表的类型擦除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型擦除跟多态的冲突"><a href="#类型擦除跟多态的冲突" class="headerlink" title="类型擦除跟多态的冲突"></a>类型擦除跟多态的冲突</h3><p>类型擦除带来一个问题，会跟多态冲突，我们看一个导致冲突的例子：</p>
<p>定义一个泛型类Person，有一个contactPerson成员，由于联系人可能是一个字符串表示电话号码，也可能是一个Father对象表示Father作为联系人的相关信息，也可能是一个Mother对象等，所以这里定义contactPerson类型为泛型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T contactPerson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getContactPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contactPerson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(T contactPerson)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contactPerson = contactPerson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个学生类继承Person类，我们在学生类里覆盖setContactPerson方法，我们认为如果是学生，就把联系人定位老师，在setContactPerson方法里添加是”contact person is teacher“的描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(String contactPerson)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setContactPerson(<span class="string">"contact person is teacher "</span> + contactPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student xiaoming = <span class="keyword">new</span> Student();</span><br><span class="line">        Person&lt;String&gt; p1 = xiaoming;</span><br><span class="line">        p1.setContactPerson(<span class="string">"025-11111111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person<string> p1 = xiaoming;这里将父类的变量指向子类的引用，子类对父类的方法进行重写，这其实就是多态，p1.setContactPerson(“025-11111111”);调用的是子类对象的方法。</string></p>
<p>类型擦除之后：<br>父类Person</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object contactPerson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getContactPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contactPerson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(Object contactPerson)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.contactPerson = contactPerson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类Student</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(String contactPerson)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setContactPerson(<span class="string">"contact person is teacher "</span> + contactPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到经过类型擦除，父类的方法是public void setContactPerson(Object contactPerson),子类的方法是public void setContactPerson(String contactPerson)，子类方法和父类方法只是函数名相同，但是方法签名里的参数类型不一样了，这时候按照传统的理解是函数重载，而不是重写了，我们本意是实现多态，我们发现类型擦除导致了跟多态的冲突。</p>
<p>那么我们看一下我们上面的分析是不是对的，进行如下的test：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student xiaoming = <span class="keyword">new</span> Student();</span><br><span class="line">        Person p1 = xiaoming;</span><br><span class="line">        p1.setContactPerson(<span class="keyword">new</span> Object());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入Obejct类型的参数，这个时候如果是重载的话，就会调用父类的setContactPerson方法，但是出现了运行异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.base/java.lang.Object cannot be cast to java.base/java.lang.String</span><br><span class="line">	at com.Student.setContactPerson(Student.java:<span class="number">3</span>)</span><br><span class="line">	at com.Main.main(Main.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>

<p>无法将Object类型转换为String类型，而且报错的位置是Student的方法，这说明并没有发生重载，仍然是重写，调用的仍然是子类的方法，那这是为什么呢？</p>
<p>这是因为JVM自动采用了一种<strong>桥方法</strong>的办法来解决类型擦除跟多态的冲突。</p>
<p>对Student.class文件反编译一下:javap -c Student.class，得到如下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Student.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">Student</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">Person</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.Student();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method com/Person."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: invokedynamic #2,  0              // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">       7: invokespecial #3                  // Method com/Person.setContactPerson:(Ljava/lang/Object;)V</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: checkcast     #4                  // class java/lang/String</span><br><span class="line">       5: invokevirtual #5                  // Method setContactPerson:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到Student类反编译后里面有两个方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7: invokespecial #3                  // Method com/Person.setContactPerson:(Ljava/lang/Object;)V</span><br><span class="line">5: invokevirtual #5                  // Method setContactPerson:(Ljava/lang/String;)V</span><br></pre></td></tr></table></figure>

<p>并且可以看出这两个方法的关系是:7: invokespecial #3 // Method com/Person.setContactPerson:(Ljava/lang/Object;)V调用5: invokevirtual #5 // Method setContactPerson:(Ljava/lang/String;)V。</p>
<p>也就是说JVM自动生成了一个额外的桥方法，也就是类型擦除后，Student类的真实面目是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(String contactPerson)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setContactPerson(<span class="string">"contact person is teacher "</span> + contactPerson);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContactPerson</span><span class="params">(Object contactPerson)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	setContactPerson((String)contactPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子类和父类都拥有public void setContactPerson(Object contactPerson)方法，即使传入的参数类型是Object对象，调用的也是子类方法，只不过子类方法再调用了一次public void setContactPerson(String contactPerson)，通过上面的分析，可以看到JVM就是通过桥方法解决类型擦除跟多态之前的冲突的。</p>
<p>进一步考虑一下，setContactPerson是有参数列表的，如果子类Student还重写了父类的getContactPerson()方法呢，这个时候类型擦除了之后，父类的getContactPerson为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getContactPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> contactPerson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类的getContactPerson方法为：</p>
<p>public String getContactPerson()<br>{<br>    retrn super.getContactPerson();<br>}<br>只有返回值不一样，这其实就是正常的重写，按道理不需要桥方法过渡了，我们看一下编译后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Student.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">Student</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">Person</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.Student();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method com/Person."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getContactPerson</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #2                  // Method com/Person.getContactPerson:()Ljava/lang/Object;</span><br><span class="line">       4: checkcast     #3                  // class java/lang/String</span><br><span class="line">       <span class="number">7</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getContactPerson</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokevirtual #4                  // Method getContactPerson:()Ljava/lang/String;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到JVM仍然为getContactPerson生成了一个桥方法：public java.lang.Object getContactPerson();，那这个时候Student类进行类型擦除后，有两个getContactPerson()方法，它们的区别仅仅是返回值类型不一样，按道理这编译都会报错的，会报方法冲突的。<br>**<br>这是因为在虚拟机中用参数列表和返回值类型一起来确定一个方法，所以不会有方法冲突。所以这里跟编译器只通过参数列表来确定一个方法是不同的。**</p>
<p><strong>关于类型擦除的几点总结：</strong></p>
<blockquote>
<ol>
<li>虚拟机中没有泛型，只有普通类和方法；</li>
<li>所有类型参数都用限定类型或者Object替换；</li>
<li>JVM通过桥方法来保持多态；</li>
<li>为保持类型安全性，必要时插入强制类型转换。</li>
</ol>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的泛型-一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的泛型-一/" itemprop="url">说说java中的泛型(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T12:16:20+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h2><h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>泛型的本质就是参数化类型。我们知道定义一个变量的时候会为其指定一个类型，比如定义Student类的对象Student xiaoming，Student即为变量xiaoming的类型，现在我们把这个具体的类型参数化，也就是说用参数变量来代替xiaoming的类型，这就是参数化类型。</p>
<p>当参数化类型被应用在类、接口、方法中的时候，对应的即为泛型类、泛型接口、泛型方法。</p>
<h3 id="为什么要引入泛型？"><a href="#为什么要引入泛型？" class="headerlink" title="为什么要引入泛型？"></a>为什么要引入泛型？</h3><p>不难理解，泛型编程可以使得编写的代码能被不同的类型对象所重用，只要传递不同的类型参数实参给类型参数就可以实现代码重用。</p>
<p>比如我们想定义一个集合分别存储String对象和Student对象，我们可不想设计一个StringArray来存String对象，再另外设计一个StudentArray来存Student对象。</p>
<p>我们知道ArrayList类就可以解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Student xiaoming = <span class="keyword">new</span> Student();</span><br><span class="line">        arrayList.add(<span class="string">"hello"</span>);</span><br><span class="line">        arrayList.add(xiaoming);</span><br><span class="line"></span><br><span class="line">        String hello = (String)arrayList.get(<span class="number">0</span>);</span><br><span class="line">        String world = (String)arrayList.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以向ArrayList对象存入String对象和Student对象，但是有两个问题：</p>
<blockquote>
<ol>
<li>arrayList.get()获取元素的时候，需要进行强制类型转换，否则会有编译问题；</li>
<li>我们看到String world = (String)arrayList.get(1);并没有报编译错误，但是在运行的时候，会报类型转换异常。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: com.Student cannot be cast to java.base/java.lang.String</span><br><span class="line">	at com.Main.main(Main.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>之所以有这两个问题，是因为不知道arrayList存入的元素类型，为了在编译阶段就解决这些问题，引入泛型，给ArrayList传入类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList &lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>指定了类型参数，那么arrayList.add(xiaoming)就不会报编译错误；而且get方法也不需要进行强制类型转换了。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>将类的成员变量类型参数化，即为泛型类。</p>
<p>定义一个普通类Result</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个String类型的成员变量，我们将其参数化，即得到泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复用泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Result&lt;String&gt; stringResult = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">        Result&lt;Integer&gt; integerResult = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">        stringResult.setValue(<span class="string">"hello"</span>);</span><br><span class="line">        integerResult.setValue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(stringResult.getValue());</span><br><span class="line">        System.out.println(integerResult.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了对泛型类的复用，否则就得定义一个类处理String成员，再定义另外一个类来处理Integer成员，这里引入了类型变量T，用&lt;&gt;括起来放在类名后面，泛型类也可以有多个类型变量，比如public class Result&lt;T,U&gt;{…}。java中用E表示集合的元素类型，用K和V表示map中的key和value的类型，用T以及临近的U和S表示任意类型。</p>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口和泛型类比较类似，将成员或方法类型参数化，看一个泛型接口的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compute</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个类实现该接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Compute</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">add</span><span class="params">(Integer a, Integer b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数调用</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student xiaoming = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(xiaoming.add(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>将方法的形参以及返回值参数类型化，即得到泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T[] num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num[num.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只要是想获取数组中间元素，给getMiddle方法，传入该数组即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] names =</span><br><span class="line">        &#123; <span class="string">"james"</span>, <span class="string">"kobe"</span>, <span class="string">"mcGrady"</span> &#125;;</span><br><span class="line">        Integer[] numbers =</span><br><span class="line">        &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        System.out.println(getMiddle(names));</span><br><span class="line">        System.out.println(getMiddle(numbers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T[] num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num[num.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kobe</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>泛型方法可以定义在普通类中，也可以定义在泛型类中。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的断言/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的断言/" itemprop="url">说说java中的断言</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T11:44:12+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>断言也是java中的一种异常处理手段，主要用于开发和测试阶段对程序的调试。相比于抛出异常和捕获异常，断言处理机制允许在测试期间在代码中插入一些断言检查语句，当代码发布的时候通过使能和去使能断言开关可以灵活的控制是否执行断言检查，这样不会因为有大量的异常判断而导致程序性能降低。</p>
<h2 id="一-断言的基本语法"><a href="#一-断言的基本语法" class="headerlink" title="一. 断言的基本语法"></a>一. 断言的基本语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> 条件</span><br><span class="line"><span class="keyword">assert</span> 条件 : 表达式</span><br></pre></td></tr></table></figure>

<p>如果条件是false，则抛出AssertionError异常，在第二种形式中，表达式将被传入AssertionError构造器，并转换成一个消息字符串，对异常进行一个详细描述。</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> number = input.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言判断输入的参数是否为正整数</span></span><br><span class="line">        <span class="keyword">assert</span> number &gt; <span class="number">0</span> : <span class="string">"input number is not positive!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编辑器开启断言编译</strong><br>编辑器默认一般都是不开启断言的，所以我们要手动开启断言，以idea为例：<br>Run-&gt;Edit Configurations-&gt;在Configuration的VM optons里输入-ea(-enableAssertions的缩写)即可。</p>
<p>输入-1，结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.AssertionError: input number is not positive!</span><br><span class="line">	at com.Main.main(Main.java:<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="二-断言使用场景"><a href="#二-断言使用场景" class="headerlink" title="二. 断言使用场景"></a>二. 断言使用场景</h2><ol>
<li><p>在私有方法中使用assert作为输入参数的校验<br>公有方法一般不使用assert进行参数教研，公有方法调用是开放的，入参不可控，调用方获得AssertionError错误信息，可能导致程序终止。</p>
</li>
<li><p>在流程控制中不可能达到的地方使用assert<br>assert此时表示的意义是：程序执行到这里就是错误的。</p>
</li>
</ol>
<h2 id="三-参考文献"><a href="#三-参考文献" class="headerlink" title="三. 参考文献"></a>三. 参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的异常处理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的异常处理机制/" itemprop="url">说说java中的异常处理机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T11:08:23+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“每天上班干嘛的？“”写bug的啊“。对于程序开发来说，bug太正常了，有的bug是开发人员的疏漏造成的，有的bug跟用户的操作以及程序运行的环境有关，但是不管怎么说，遇到bug总归不是一件愉悦的事情，那么如何优雅的处理程序中的bug呢，怎么把一件不怎么愉悦的事情变得稍微愉悦一点呢？java使用一种异常处理（exception handing）机制来处理程序中的异常。</p>
<h2 id="一-异常分类"><a href="#一-异常分类" class="headerlink" title="一. 异常分类"></a>一. 异常分类</h2><p>java中的所有异常均派生自Throwable类，Throwable类派生出Error类和Exception类。</p>
<p><strong>Error类</strong>：Error类及其子类的实例描述了java运行时系统的内部错误和资源耗尽错误，代表的是jvm本身的错误，应用程序不应该抛出这种类型的异常，因为对于这类异常，上层应用程序也无能为力，所以我们更应该关注Excepton类的异常。</p>
<p><strong>Exception类</strong>：Exception类又派生出两个分支，一个是RuntimeException类；一个是其他异常。由程序错误导致的（比如访问空指针、数组越界、错误的类型转换等）异常为RuntimeException，而由于IO问题，用户输入类型不匹配等导致的异常属于其他异常。</p>
<p><strong>Error和Exception的区别</strong>：Error通常是指灾难性的致命错误，程序无法控制和处理，当出现这种错误时，jvm一般会终止线程；Exception通常是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p>
<h3 id="已检查异常与未检查异常"><a href="#已检查异常与未检查异常" class="headerlink" title="已检查异常与未检查异常"></a>已检查异常与未检查异常</h3><p><strong>未检查异常</strong>：java语言规范将Error类以及RuntimeException类的所有异常称为未检查异常。对于这种异常我们应该修正代码，而不是通过异常处理器进行处理。</p>
<p><strong>已检查异常</strong>：其他的异常称为已检查异常。对于这类异常，要么用try-catch语句进行捕获处理，或者通过throws语句抛出。</p>
<h2 id="二-异常处理机制"><a href="#二-异常处理机制" class="headerlink" title="二. 异常处理机制"></a>二. 异常处理机制</h2><p>java中的异常处理机制本质上是:抛出异常+捕获异常。</p>
<h3 id="抛出异常（throw和throws）"><a href="#抛出异常（throw和throws）" class="headerlink" title="抛出异常（throw和throws）"></a>抛出异常（throw和throws）</h3><p>java中的异常抛出使用throw和throws关键字来实现。</p>
<p>throw：一般用于抛出异常，后面接具体的异常对象；throws可以单独使用，但是throw要么和try-catch-finally语句配套使用，要么与throws配套使用。</p>
<p>throws：在方法签名后，用于声明该方法可能抛出的异常。</p>
<p>对于已检查异常要么进行捕获，要么进行抛出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> number = input.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-try-catch-finally语句"><a href="#捕获异常-try-catch-finally语句" class="headerlink" title="捕获异常(try-catch-finally语句)"></a>捕获异常(try-catch-finally语句)</h3><p>捕获异常的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//code1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//code2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//code3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//code4</span></span><br></pre></td></tr></table></figure>

<p>try:用于监听，将要被监听的代码放在try语句块之内，一旦发现程序异常，异常就会被抛出；<br>catch：用于捕获异常，匹配到异常后，对异常进行处理，多重catch语句时，注意子类在前，父类在后；<br>finally：始终会执行到，用于关闭文件和资源释放。</p>
<h2 id="三-异常链"><a href="#三-异常链" class="headerlink" title="三. 异常链"></a>三. 异常链</h2><p>在catch语句中可以抛出一个异常，这样相当于对捕获的异常进行了一个包装，改变异常的类型，比如子系统A供系统B调用，如果子系统A异常了，只是想知道子系统A是否故障，可以在子系统A的catch语句里再次抛出异常：throw new SystemAException()。其中SystemAException为自定义的表示系统A故障了的异常。</p>
<p>但是这样有一个问题，在系统B里不知道具体的原始异常是什么，只知道封装后的异常。可以采用异常链的方式，将原始异常设置为新异常的”诱饵”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">	Throwable se = <span class="keyword">new</span> SystemAException();</span><br><span class="line">    se.initcause(e);</span><br><span class="line">    <span class="keyword">throw</span> se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当捕获到异常后，通过Throwable e = se.getCause()就可以获得原始异常了。</p>
<h2 id="四-自定义异常"><a href="#四-自定义异常" class="headerlink" title="四. 自定义异常"></a>四. 自定义异常</h2><p>如果标准异常库不能充分描述异常问题，可以自定义异常，定义一个类继承Exception或者继承Excpetion的子类即可，定义的类应该包括两个构造器，一个默认构造器，一个带有详细描述信息的构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptoin</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExceptoin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExceptoin</span><span class="params">(String gripe)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出自定义异常</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, MyExceptoin</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"D:\\test.txt"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> number = input.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyExceptoin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的static关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的static关键字/" itemprop="url">说说java中的static关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T11:01:15+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java中的static关键字用的地方还是挺多的，静态变量、静态方法、静态代码块等等，感觉需要好好总结一下，本文就说说java中的static关键字。</p>
<h2 id="static关键字的六中用法"><a href="#static关键字的六中用法" class="headerlink" title="static关键字的六中用法"></a>static关键字的六中用法</h2><p>在java中static关键字表示“全局”或者“静态”的意思，被static修饰则不需要依赖于具体的对象实例，可以方便在没有创建对象的情况下进行调用（方法/变量等）。</p>
<p>我们知道静态方法、静态变量等，其实在java中static关键字一共有六种用法：</p>
<blockquote>
<ol>
<li>静态变量；</li>
<li>静态常量；</li>
<li>静态方法；</li>
<li>静态导入；</li>
<li>静态代码块；</li>
<li>静态内部类；</li>
</ol>
</blockquote>
<h2 id="一-静态变量"><a href="#一-静态变量" class="headerlink" title="一. 静态变量"></a>一. 静态变量</h2><p>static变量和非static变量的区别是：static变量不依赖于具体的对象实例，是属于类的，static变量由所有的对象共享，在内存中只有一个副本。非static变量是依赖于对象实例的，每个对象拥有不同的变量副本。通过一个例子看的比较清楚：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> totalStudentNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> studentNum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student student1 = <span class="keyword">new</span> Student();</span><br><span class="line">        student1.studentNum++;</span><br><span class="line">        student1.totalStudentNum++;</span><br><span class="line"></span><br><span class="line">        Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">        student2.studentNum++;</span><br><span class="line">        student2.totalStudentNum++;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Student.totalStudentNum is: "</span> + Student.totalStudentNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.totalStudentNum is: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="二-静态常量"><a href="#二-静态常量" class="headerlink" title="二. 静态常量"></a>二. 静态常量</h2><p>被static修饰的常量即为静态常量<code>static final PI = 3.14</code>，同静态变量一样，静态常量是属于类的，所有对象共享，不依赖于具体的对象实例。</p>
<p><code>System.out</code>其实就是一个静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrintStream out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-静态方法"><a href="#三-静态方法" class="headerlink" title="三. 静态方法"></a>三. 静态方法</h2><p>可以认为静态方法是没有this参数的方法，静态方法不依赖于对象实例，所以在静态方法中不能访问实例域，在静态方法中只能访问静态域；但是非静态方法可以访问静态域。</p>
<p>最常见的static方法即main方法，main方法之所以为static，是因为程序在执行main方法的时候没有创建任何对象，只能通过类名来访问。</p>
<h3 id="构造函数是静态方法吗？"><a href="#构造函数是静态方法吗？" class="headerlink" title="构造函数是静态方法吗？"></a>构造函数是静态方法吗？</h3><p>静态方法中是没有this参数的，而构造函数中可以使用this参数，所以认为构造函数不是static方法。</p>
<p>一般static方法适合如下场景：</p>
<blockquote>
<p>一个方法不需要访问对象状态，所需要的参数都是通过显示提供的；<br>一个方法只需要访问类的静态域。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	System.out.println(add(<span class="number">10</span>,<span class="number">11</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-静态导入"><a href="#四-静态导入" class="headerlink" title="四.静态导入"></a>四.静态导入</h2><p>静态导入是java5中的一个特性，import不仅可以导入类，还可以导入静态方法和静态域。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br></pre></td></tr></table></figure>

<p>这样就可以使用System的静态方法和静态域了，而不用在前面加类的前缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	out.println(pow(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        out.println(max(<span class="number">1</span>,<span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-静态代码块"><a href="#五-静态代码块" class="headerlink" title="五. 静态代码块"></a>五. 静态代码块</h2><p>静态代码块，就是用static修饰的代码块，作用是对静态属性进行初始化。静态代码块可以有多个，JVM加载类时会按照顺序执行这些静态代码块。</p>
<p>关于代码块，主要分为四类：</p>
<h3 id="普通代码块"><a href="#普通代码块" class="headerlink" title="普通代码块"></a>普通代码块</h3><p>即正常的比如一个方法{}之间的代码段；</p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><p>用static修饰的代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> totalNum;</span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">    	totalNum = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化代码块"><a href="#初始化代码块" class="headerlink" title="初始化代码块"></a>初始化代码块</h3><p>在一个类中，不带任何修饰{}包含的代码段，只要构造类的对象，这些块就会被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">    	name = <span class="string">"xiaoming"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化块和静态代码块的区别</strong>：</p>
<blockquote>
<ol>
<li>静态代码块只会执行一次，有多个静态代码块按顺序执行；</li>
<li>初始化代码块，每次创建对象都会执行；</li>
<li>执行顺序：静态代码块&gt;初始化代码块&gt;构造函数</li>
</ol>
</blockquote>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>同步代码块多用于线程互斥，用synchronized修饰的{}包含的代码，表示同一时间只能有一个线程进入同步代码块。</p>
<h2 id="六-静态内部类"><a href="#六-静态内部类" class="headerlink" title="六. 静态内部类"></a>六. 静态内部类</h2><p>用static修饰的内部类即为静态内部类，静态内部类不依赖于外部类的实例。</p>
<p>静态内部类不需要依赖外部类的对象；<br>静态内部类只能反问外部类的静态成员而不能访问其他域。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/说说java中的lambda表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content>
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="i2Life">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/22/说说java中的lambda表达式/" itemprop="url">说说java中的lambda表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T10:55:02+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ambda表达式是java8推出的一个特性，使用lambda表达式可以很方便地传递代码块，使得代码更加的简洁，本文就主要说说java中的lambda表达式。</p>
<h2 id="lambda表达式的语法"><a href="#lambda表达式的语法" class="headerlink" title="lambda表达式的语法"></a>lambda表达式的语法</h2><p>lambda表达式就是一个代码块，以及必须传入代码的变量规范。lambda表达式格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码块&#125;</span><br></pre></td></tr></table></figure>

<p>语法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example <span class="number">1</span>:</span><br><span class="line">()-&gt;&#123;System.out.println(<span class="string">"hello"</span>);&#125;</span><br><span class="line"></span><br><span class="line">exmaple <span class="number">2</span>:</span><br><span class="line">(String m, String n)-&gt;&#123;<span class="keyword">return</span> m.length()-n.length();&#125;</span><br><span class="line"><span class="comment">//如果参数能通过上下文确定类型，可以省略参数列表里的参数类型</span></span><br><span class="line">(m,n)-&gt;&#123;<span class="keyword">return</span> m.length()-n.length();&#125;</span><br><span class="line"></span><br><span class="line">example <span class="number">3</span>:</span><br><span class="line"><span class="comment">//如果只有一个参数，小括号可以省略</span></span><br><span class="line">x-&gt;&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"></span><br><span class="line">example <span class="number">4</span>:</span><br><span class="line"><span class="comment">//如果代码块里只有一条语句，则return和大括号可以省略</span></span><br><span class="line">x-&gt;x*x</span><br></pre></td></tr></table></figure>

<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>lambda表达式是不能独立执行的，所以可以由指定目标类型的函数式接口对lambda表达式进行调用。<br>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式，这种接口称为函数式接口(functional interface)。</p>
<p>lambda表达式可以转换为一个接口，让lambda表达式更有吸引力了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数式接口</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Compute</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过lambda表达式实现接口的抽象方法</span></span><br><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Compute compute = (x, y) -&gt; x + y;</span><br><span class="line">        System.out.println(compute.add(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>又比如要对一个数组进行排序，调用Arrays.sort()方法，第二个参数是一个Comparator对象实例，Comparator就是只有一个方法的接口，所以可以提供一个lambda表达式作为sort方法的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] arr =</span><br><span class="line">        &#123; <span class="string">"Champions"</span>, <span class="string">"we"</span>, <span class="string">"yeah"</span>, <span class="string">"are"</span> &#125;;</span><br><span class="line">        Arrays.sort(arr, (m, n) -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.length() &gt; n.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印排序后的数组</span></span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(arr);</span><br><span class="line">        names.forEach(name -&gt; System.out.println(name + <span class="string">";"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Champions;</span><br><span class="line">yeah;</span><br><span class="line">are;</span><br><span class="line">we;</span><br></pre></td></tr></table></figure>

<h2 id="方法引用-method-reference"><a href="#方法引用-method-reference" class="headerlink" title="方法引用(method reference)"></a>方法引用(method reference)</h2><p>方法引用可以认为是lambda表达式的一个扩展，有时候lambda表达式只是引用了一个已经声明过的方法，为了增加可读性，可以使用方法引用。使用::操作符调用引用方法，常用的主要有4类方法引用：</p>
<blockquote>
<ol>
<li>objectInstance::instanceMethod引用实例变量的方法</li>
<li>Class::staticMethod引用类的静态方法</li>
<li>Class::instanceMethod特定类型的方法引用</li>
<li>Class::new引用构造方法</li>
</ol>
</blockquote>
<p>对于第一种情况，比如System.out::println，等价于x-&gt;System.out.println(x)；<br>对于第二种情况，比如Math::pow，等价于(x,y)-&gt;Math.pow(x,y);<br>对于第三种情况，比如String::compareToIngoreCase，等价于(x,y)-&gt;x.compareToIngoreCase(y);<br>对于第四种情况，比如String::new，等价于()-&gt;new String();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器事件：打印事件名称</span></span><br><span class="line"><span class="comment">//lambda表达式如下</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>, event-&gt;System.our.println(event));</span><br><span class="line"><span class="comment">//通过方法引用，改写为如下：</span></span><br><span class="line">Timer t = <span class="keyword">new</span> Timer(<span class="number">1000</span>,System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.douban.com/link2/?url=https%3A%2F%2Fbook.douban.com%2Fsubject%2F3146174%2F&query=java%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9D%9F&cat_id=1001&type=search&pos=1" target="_blank" rel="noopener">java核心技术.卷一</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description">welcome to i2Life's page</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
